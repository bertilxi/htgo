# Quick Summary: Auto-Discovery of Loaders in HTGO

## Findings at a Glance

### 1. Go Plugin System: NOT VIABLE
- Breaks single-binary deployment model
- Platform limited (Linux/macOS only)
- ABI instability risks
- No error isolation
- Contradicts HTGO's design goals

### 2. Reflection-Based Discovery: PROBLEMATIC
- Requires architectural refactoring
- Runtime overhead (slow)
- Loses compile-time safety
- No IDE support for bare functions
- Would need to restructure pages as methods on a type

### 3. Build-Time Code Generation: RECOMMENDED ✓
- Zero runtime overhead
- Type-safe (compiler checks generated code)
- Works across all platforms
- Single-binary deployment maintained
- Aligns with HTGO's simplicity philosophy

### 4. Current HTGO Architecture

**Existing Infrastructure**
- Already uses `go/ast` for static code analysis
- `ListLoaderFiles()` scans for loader files
- `isValidLoaderSignature()` validates function types
- Comments explicitly state "functions must be registered manually"

**Current Pattern**
```go
// Every page needs manual registration
Loaders: map[string]func(c *gin.Context) (any, error){
    "/":      pages.LoadIndex,      // Manual entry
    "/about": pages.LoadAbout,      // Manual entry
}
```

---

## Recommended Solution

### Build-Time Code Generation with Naming Convention

**How It Works**
```
Developer writes loader functions
pages/index.go  → func LoadIndex()
pages/about.go  → func LoadAbout()
              ↓
Run: go generate ./...
              ↓
Generates: pages/loaders_generated.go
              ↓
App uses: Loaders: pages.LoaderRegistry
```

**Naming Convention**
```
pages/index.go            → LoadIndex      → /
pages/about.go            → LoadAbout      → /about
pages/blog/[slug].go      → LoadBlogSlug   → /blog/:slug
pages/admin/users.go      → LoadAdminUsers → /admin/users
pages/user_profile.go     → LoadUserProfile → /user-profile
```

**Generated Registry**
```go
// Code generated by htgo generate; DO NOT EDIT
package pages

var LoaderRegistry = map[string]func(c *gin.Context) (any, error){
    "/":           LoadIndex,
    "/about":      LoadAbout,
    "/blog/:slug": LoadBlogSlug,
}
```

---

## Advantages

| Feature | Benefit |
|---------|---------|
| **Zero Boilerplate** | No manual list of loaders needed |
| **Auto-Discovery** | New loaders work after regeneration |
| **Type Safe** | Compiler checks generated code |
| **No Runtime Cost** | Everything happens at build time |
| **Single Binary** | Works with go:embed deployment |
| **Debuggable** | Generated code is readable |
| **Reversible** | Easy to switch back if needed |
| **HTGO Philosophy** | Boring, simple, explicit |

---

## Trade-offs

**What We Gain**
- Eliminate manual registration boilerplate
- Convention-driven development
- Automatic discovery of new loaders

**What We Lose**
- Flexibility for non-standard naming
- One extra build step (go generate)
- Harder to selectively disable loaders

**Mitigation**
- Keep `go:generate` automatic in dev/build CLI commands
- Support manual overrides for edge cases
- Clear, simple naming rules

---

## Implementation Phases

### Phase 1: Generator Tool
- Extract AST parsing from router.go
- Create `cmd/htgo-gen-loaders` tool
- Output: `pages/loaders_generated.go`

### Phase 2: CLI Integration
- Add `htgo generate` command
- Auto-run in `htgo dev` and `htgo build`
- Update CLAUDE.md with naming convention

### Phase 3: Enhancement (Optional)
- `--manual-only` flag for explicit projects
- Support custom routing overrides
- IDE tooling/linting helpers

---

## Key Files in HTGO Codebase

**Already Has Static Analysis:**
- `/home/berti/Code/3lines/htgo/router.go` (lines 15-166)
  - `DiscoverPages()` - finds .tsx files
  - `ListLoaderFiles()` - finds colocated .go files
  - `isValidLoaderSignature()` - validates via AST

**Current Manual Registration:**
- `/home/berti/Code/3lines/htgo/examples/sink/app.go` (lines 45-48)
  - Shows current manual pattern with Loaders map

**AST Analysis Functions Ready to Reuse:**
- `isGinContextType()` - validates parameter types
- `isAnyType()` - validates return types  
- `isErrorType()` - validates return types

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|-----------|
| Developer forgets generate | High | Loaders ignored | Auto-run in dev/build |
| Naming convention errors | Medium | Build-time errors | Clear docs, linting |
| Generated file conflicts | Low | Merge issues | DO NOT EDIT marker |
| Performance impact | None | N/A | No runtime cost |

---

## Next Steps

1. **Prototype** code generator tool using existing AST code
2. **Test** with examples/sink and examples/minimal
3. **Document** naming convention in CLAUDE.md
4. **Integrate** with `htgo dev` and `htgo build` commands
5. **Update** examples to use LoaderRegistry

---

## Why This is the Best Choice

For HTGO, build-time generation is ideal because:

1. **Matches Philosophy**: Boring, explicit, predictable
2. **Zero Cost**: No runtime overhead or complexity
3. **Type Safe**: Works with Go's compiler
4. **Platform Neutral**: Works everywhere go build works
5. **Reversible**: Easy to maintain/modify generated code
6. **Leverages Existing Code**: Reuses router.go AST analysis

This is exactly what Berti meant by "simplicity first" - no runtime magic, just straightforward generated Go code.
