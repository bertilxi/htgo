package cli

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/bertilxi/alloy/loaderutil"
)

// findModuleInfo walks up from startDir to find go.mod and returns (moduleName, moduleRootDir)
func findModuleInfo(startDir string) (string, string) {
	currentDir := startDir
	for {
		gomodPath := filepath.Join(currentDir, "go.mod")
		if data, err := os.ReadFile(gomodPath); err == nil {
			scanner := bufio.NewScanner(strings.NewReader(string(data)))
			for scanner.Scan() {
				line := scanner.Text()
				if strings.HasPrefix(line, "module ") {
					moduleName := strings.TrimSpace(strings.TrimPrefix(line, "module"))
					return moduleName, currentDir
				}
			}
		}

		parent := filepath.Dir(currentDir)
		if parent == currentDir {
			break
		}
		currentDir = parent
	}
	return "", ""
}

// calculateAPIImportPath calculates the full Go import path for the api package
func calculateAPIImportPath(pagesDir string, moduleName, moduleRoot string) string {
	// Get absolute path of pagesDir
	absPagesDir, err := filepath.Abs(pagesDir)
	if err != nil {
		return ""
	}

	// Get absolute path of module root
	absModuleRoot, err := filepath.Abs(moduleRoot)
	if err != nil {
		return ""
	}

	// Calculate relative path from module root to api directory
	relPath, err := filepath.Rel(absModuleRoot, filepath.Join(absPagesDir, "api"))
	if err != nil {
		return ""
	}

	// Convert file path separators to forward slashes for Go imports
	relPath = filepath.ToSlash(relPath)

	// Construct the full import path
	return moduleName + "/" + relPath
}

// GenerateLoaders creates the loader registry in the pages directory
func GenerateLoaders(pagesDir string) error {
	if pagesDir == "" {
		pagesDir = "pages"
	}

	// Check if directory exists
	info, err := os.Stat(pagesDir)
	if err != nil || !info.IsDir() {
		// Silently skip if pages directory doesn't exist
		return nil
	}

	fmt.Printf("üìù Generating loader registry...\n")

	// Discover loaders
	loaders, err := loaderutil.DiscoverLoaders(pagesDir)
	if err != nil {
		fmt.Printf("‚ö†Ô∏è  Warning: failed to discover loaders: %v\n", err)
		return nil
	}

	if len(loaders) == 0 {
		// No loaders found, but that's okay
		return nil
	}

	// Sort loaders by route for consistent output
	sort.Slice(loaders, func(i, j int) bool {
		return loaders[i].Route < loaders[j].Route
	})

	// Get module name and root for API imports
	absPagesDir, _ := filepath.Abs(pagesDir)
	moduleName, moduleRoot := findModuleInfo(filepath.Dir(absPagesDir))
	apiImportPath := ""
	if moduleName != "" && moduleRoot != "" {
		apiImportPath = calculateAPIImportPath(pagesDir, moduleName, moduleRoot)
	}

	// Generate code
	code := generateLoaderRegistry(pagesDir, apiImportPath, loaders)

	// Write to file
	outputFile := filepath.Join(pagesDir, "loaders_generated.go")
	err = os.WriteFile(outputFile, []byte(code), 0644)
	if err != nil {
		fmt.Printf("‚ö†Ô∏è  Warning: failed to write %s: %v\n", outputFile, err)
		return nil
	}

	fmt.Printf("‚úì Generated %s with %d loaders\n", outputFile, len(loaders))
	return nil
}

func generateLoaderRegistry(pagesDir, apiImportPath string, loaders []loaderutil.LoaderInfo) string {
	// Get package name from directory
	pkgName := filepath.Base(pagesDir)

	var sb strings.Builder

	// Determine if we need to import the api package
	hasAPIHandlers := false
	for _, loader := range loaders {
		if loader.IsAPI {
			hasAPIHandlers = true
			break
		}
	}

	// Header with go:generate comment
	sb.WriteString(fmt.Sprintf(`// Code generated by alloy. DO NOT EDIT.
// Generated for loaders in %s/

package %s

import (
	"github.com/bertilxi/alloy"
	"github.com/gin-gonic/gin"`, pagesDir, pkgName))

	if hasAPIHandlers && apiImportPath != "" {
		sb.WriteString(fmt.Sprintf(`
	api "%s"`, apiImportPath))
	}

	sb.WriteString(`
)

// LoaderRegistry maps page routes to their corresponding loader functions.
// Loaders return (any, error) and their data is used as props for SSR.
var LoaderRegistry = map[string]alloy.PageLoader{
`)

	// Add each page loader (not API handlers)
	for _, loader := range loaders {
		if !loader.IsAPI {
			sb.WriteString(fmt.Sprintf(`	"%s": %s,
`, loader.Route, loader.FunctionName))
		}
	}

	sb.WriteString(`}

// HandlerRegistry maps API routes to their corresponding handler functions.
var HandlerRegistry = map[string]gin.HandlerFunc{
`)

	// Add each API handler
	for _, loader := range loaders {
		if loader.IsAPI {
			var funcRef string
			if apiImportPath != "" {
				funcRef = "api." + loader.FunctionName
			} else {
				funcRef = loader.FunctionName
			}
			sb.WriteString(fmt.Sprintf(`	"%s": %s,
`, loader.Route, funcRef))
		}
	}

	sb.WriteString(`}
`)

	return sb.String()
}

// ensureGeneratedLoaders checks if loaders_generated.go exists, if not generates it
func ensureGeneratedLoaders(pagesDir string) error {
	if pagesDir == "" {
		pagesDir = "pages"
	}

	generatedFile := filepath.Join(pagesDir, "loaders_generated.go")

	// Check if file exists
	_, err := os.Stat(generatedFile)
	if err == nil {
		// File exists, we're good
		return nil
	}

	// File doesn't exist, generate it
	return GenerateLoaders(pagesDir)
}
