// alloy-gen-loaders generates a loader registry from colocated .go files
// Usage: alloy-gen-loaders [pagesDir]
package main

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/bertilxi/alloy/loaderutil"
)

// findModuleInfo walks up from startDir to find go.mod and returns (moduleName, moduleRootDir)
func findModuleInfo(startDir string) (string, string) {
	currentDir := startDir
	for {
		gomodPath := filepath.Join(currentDir, "go.mod")
		if data, err := os.ReadFile(gomodPath); err == nil {
			scanner := bufio.NewScanner(strings.NewReader(string(data)))
			for scanner.Scan() {
				line := scanner.Text()
				if strings.HasPrefix(line, "module ") {
					moduleName := strings.TrimSpace(strings.TrimPrefix(line, "module"))
					return moduleName, currentDir
				}
			}
		}

		parent := filepath.Dir(currentDir)
		if parent == currentDir {
			break
		}
		currentDir = parent
	}
	return "", ""
}

// calculateAPIImportPath calculates the full Go import path for the api package
func calculateAPIImportPath(pagesDir string, moduleName, moduleRoot string) string {
	// Get absolute path of pagesDir
	absPagesDir, err := filepath.Abs(pagesDir)
	if err != nil {
		return ""
	}

	// Get absolute path of module root
	absModuleRoot, err := filepath.Abs(moduleRoot)
	if err != nil {
		return ""
	}

	// Calculate relative path from module root to api directory
	relPath, err := filepath.Rel(absModuleRoot, filepath.Join(absPagesDir, "api"))
	if err != nil {
		return ""
	}

	// Convert file path separators to forward slashes for Go imports
	relPath = filepath.ToSlash(relPath)

	// Construct the full import path
	return moduleName + "/" + relPath
}

func main() {
	flag.Parse()

	// Get pages directory from first arg or default to "pages"
	pagesDir := "pages"
	if flag.NArg() > 0 {
		pagesDir = flag.Arg(0)
	}

	// Discover loaders
	loaders, err := loaderutil.DiscoverLoaders(pagesDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}

	// Sort loaders by route for consistent output
	sort.Slice(loaders, func(i, j int) bool {
		return loaders[i].Route < loaders[j].Route
	})

	// Get module name and root for API imports
	absPagesDir, _ := filepath.Abs(pagesDir)
	moduleName, moduleRoot := findModuleInfo(filepath.Dir(absPagesDir))
	apiImportPath := ""
	if moduleName != "" && moduleRoot != "" {
		apiImportPath = calculateAPIImportPath(pagesDir, moduleName, moduleRoot)
	}

	// Generate code
	code := generateRegistry(pagesDir, apiImportPath, loaders)

	// Write to file
	outputFile := filepath.Join(pagesDir, "loaders_generated.go")
	err = os.WriteFile(outputFile, []byte(code), 0644)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error writing %s: %v\n", outputFile, err)
		os.Exit(1)
	}

	// Count loaders and API handlers
	loaderCount := 0
	apiCount := 0
	for _, loader := range loaders {
		if loader.IsAPI {
			apiCount++
		} else {
			loaderCount++
		}
	}

	fmt.Printf("âœ“ Generated %s with %d loaders and %d API handlers\n", outputFile, loaderCount, apiCount)
}

func generateRegistry(pagesDir, apiImportPath string, loaders []loaderutil.LoaderInfo) string {
	// Get package name from directory
	pkgName := filepath.Base(pagesDir)

	var sb strings.Builder

	// Determine if we need to import the api package
	hasAPIHandlers := false
	for _, loader := range loaders {
		if loader.IsAPI {
			hasAPIHandlers = true
			break
		}
	}

	// Header with go:generate comment
	sb.WriteString(fmt.Sprintf(`// Code generated by alloy-gen-loaders. DO NOT EDIT.
// Generated for handlers in %s/

package %s

import (
	"github.com/bertilxi/alloy"
	"github.com/gin-gonic/gin"`, pagesDir, pkgName))

	if hasAPIHandlers && apiImportPath != "" {
		sb.WriteString(fmt.Sprintf(`
	api "%s"`, apiImportPath))
	}

	sb.WriteString(`
)

// LoaderRegistry maps page routes to their corresponding loader functions.
// Loaders return (any, error) and their data is used as props for SSR.
var LoaderRegistry = map[string]alloy.PageLoader{
`)

	// Add each page loader
	for _, loader := range loaders {
		if !loader.IsAPI {
			sb.WriteString(fmt.Sprintf(`	"%s": %s,
`, loader.Route, loader.FunctionName))
		}
	}

	sb.WriteString(`}

// HandlerRegistry maps API routes to their corresponding handler functions.
var HandlerRegistry = map[string]gin.HandlerFunc{
`)

	// Add each API handler
	for _, loader := range loaders {
		if loader.IsAPI {
			var funcRef string
			if apiImportPath != "" {
				funcRef = "api." + loader.FunctionName
			} else {
				funcRef = loader.FunctionName
			}
			sb.WriteString(fmt.Sprintf(`	"%s": %s,
`, loader.Route, funcRef))
		}
	}

	sb.WriteString(`}
`)

	return sb.String()
}
