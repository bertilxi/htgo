# Implementation Guide: Auto-Discovery Loader Generator for HTGO

## Overview

This guide shows the technical approach to implement build-time loader auto-discovery using code generation. All the AST parsing infrastructure already exists in `router.go`.

---

## Part 1: Understanding the Current Code

### Existing AST Analysis in router.go

```go
// router.go lines 96-166 - Already analyzes loader functions!

func ListLoaderFiles(pagesDir string) ([]string, error) {
    // Walks all .go files colocated with .tsx files
    // Validates they have proper loader function signature
}

func isValidLoaderSignature(funcDecl *ast.FuncDecl) bool {
    // Checks: func(c *gin.Context) (any, error)
    return isGinContextType(param.Type) && 
           isAnyType(returnType1) && 
           isErrorType(returnType2)
}
```

**The Good News**: All the validation logic is already there. We just need to:
1. Extract it into a reusable package
2. Add route derivation from file path
3. Generate a Go file instead of just listing files

---

## Part 2: Code Generation Tool

### Strategy

Create a standalone tool that:
1. Scans a pages directory for .go files
2. Parses each file with `go/ast`
3. Finds all exported functions matching the loader signature
4. Derives the route from the file path
5. Generates a `loaders_generated.go` file

### Implementation

Create `/cmd/htgo-gen-loaders/main.go`:

```go
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

type LoaderInfo struct {
	Route    string
	Function string
}

func main() {
	pagesDir := flag.String("pages", "./pages", "pages directory")
	output := flag.String("output", "", "output file (default: {pagesDir}/loaders_generated.go)")
	flag.Parse()

	if *output == "" {
		*output = filepath.Join(*pagesDir, "loaders_generated.go")
	}

	loaders, err := discoverLoaders(*pagesDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error discovering loaders: %v\n", err)
		os.Exit(1)
	}

	code := generateRegistry(loaders)
	err = os.WriteFile(*output, code, 0644)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error writing output: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s with %d loaders\n", *output, len(loaders))
}

func discoverLoaders(pagesDir string) ([]LoaderInfo, error) {
	absPageDir, err := filepath.Abs(pagesDir)
	if err != nil {
		return nil, fmt.Errorf("failed to get absolute path: %w", err)
	}

	var loaders []LoaderInfo

	err = filepath.Walk(absPageDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() {
			return nil
		}

		if !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, "_test.go") {
			return nil
		}

		// Check if there's a corresponding .tsx file
		tsxPath := strings.TrimSuffix(path, ".go") + ".tsx"
		if _, err := os.Stat(tsxPath); err != nil {
			return nil // No corresponding .tsx file, skip
		}

		// Parse the file
		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.AllErrors)
		if err != nil {
			return nil // Skip files that can't be parsed
		}

		// Find all exported functions with loader signature
		for _, decl := range node.Decls {
			funcDecl, ok := decl.(*ast.FuncDecl)
			if !ok {
				continue
			}

			if !funcDecl.Name.IsExported() {
				continue
			}

			if isValidLoaderSignature(funcDecl) {
				route := filePathToRoute(path, absPageDir)
				loaders = append(loaders, LoaderInfo{
					Route:    route,
					Function: funcDecl.Name.Name,
				})
			}
		}

		return nil
	})

	if err != nil {
		return nil, fmt.Errorf("failed to walk directory: %w", err)
	}

	// Sort for deterministic output
	sort.Slice(loaders, func(i, j int) bool {
		return loaders[i].Route < loaders[j].Route
	})

	return loaders, nil
}

func filePathToRoute(filePath string, pagesDir string) string {
	// Same logic as router.go filePathToRoute()
	relativePath := strings.TrimPrefix(filePath, pagesDir)
	relativePath = strings.TrimPrefix(relativePath, string(filepath.Separator))
	relativePath = strings.TrimSuffix(relativePath, ".go")

	if relativePath == "index" {
		return "/"
	}

	fileParts := strings.Split(relativePath, string(filepath.Separator))
	routeParts := make([]string, len(fileParts))

	for i, part := range fileParts {
		if strings.HasPrefix(part, "[") && strings.HasSuffix(part, "]") {
			paramName := strings.TrimPrefix(part, "[")
			paramName = strings.TrimSuffix(paramName, "]")
			routeParts[i] = ":" + paramName
		} else {
			routeParts[i] = part
		}
	}

	return "/" + strings.Join(routeParts, "/")
}

func generateRegistry(loaders []LoaderInfo) []byte {
	var buf bytes.Buffer

	buf.WriteString(`// Code generated by htgo generate; DO NOT EDIT

package pages

import "github.com/gin-gonic/gin"

// LoaderRegistry maps routes to their handler functions.
// This file is auto-generated from loader functions in this package.
// To regenerate, run: go generate ./...
var LoaderRegistry = map[string]func(c *gin.Context) (any, error){
`)

	for _, loader := range loaders {
		fmt.Fprintf(&buf, "\t%q: %s,\n", loader.Route, loader.Function)
	}

	buf.WriteString("}\n")

	return buf.Bytes()
}

// Reuse validation functions from router.go
func isValidLoaderSignature(funcDecl *ast.FuncDecl) bool {
	if funcDecl.Type.Params == nil || funcDecl.Type.Results == nil {
		return false
	}

	if len(funcDecl.Type.Params.List) != 1 {
		return false
	}

	param := funcDecl.Type.Params.List[0]
	if !isGinContextType(param.Type) {
		return false
	}

	if len(funcDecl.Type.Results.List) != 2 {
		return false
	}

	if !isAnyType(funcDecl.Type.Results.List[0].Type) {
		return false
	}

	if !isErrorType(funcDecl.Type.Results.List[1].Type) {
		return false
	}

	return true
}

func isGinContextType(expr ast.Expr) bool {
	starExpr, ok := expr.(*ast.StarExpr)
	if !ok {
		return false
	}

	selExpr, ok := starExpr.X.(*ast.SelectorExpr)
	if !ok {
		return false
	}

	ident, ok := selExpr.X.(*ast.Ident)
	if !ok {
		return false
	}

	return ident.Name == "gin" && selExpr.Sel.Name == "Context"
}

func isAnyType(expr ast.Expr) bool {
	ident, ok := expr.(*ast.Ident)
	if !ok {
		return false
	}
	return ident.Name == "any"
}

func isErrorType(expr ast.Expr) bool {
	ident, ok := expr.(*ast.Ident)
	if !ok {
		return false
	}
	return ident.Name == "error"
}
```

---

## Part 3: Integration with go:generate

### In pages/package.go (or any file in pages package)

```go
package pages

//go:generate go run ../../cmd/htgo-gen-loaders -pages . -output loaders_generated.go
```

Then developers run:

```bash
$ go generate ./...
```

Or integrate into CLI:

```bash
$ htgo dev    # Auto-runs go generate before building
$ htgo build  # Auto-runs go generate before building
```

---

## Part 4: Updated Application Code

### Before (Manual Registration)

```go
// examples/sink/app.go (OLD)
Loaders: map[string]func(c *gin.Context) (any, error){
    "/":      pages.LoadIndex,
    "/about": pages.LoadAbout,
},
```

### After (Auto-Generated)

```go
// examples/sink/app.go (NEW)
Loaders: pages.LoaderRegistry  // Auto-populated!
```

---

## Part 5: Example Output

### Input Files

```
pages/
├── index.go           (LoadIndex)
├── index.tsx
├── about.go           (LoadAbout)
├── about.tsx
├── blog/
│   ├── [slug].go      (LoadBlogSlug)
│   └── [slug].tsx
└── package.go         (contains //go:generate)
```

### Generated: pages/loaders_generated.go

```go
// Code generated by htgo generate; DO NOT EDIT

package pages

import "github.com/gin-gonic/gin"

// LoaderRegistry maps routes to their handler functions.
// This file is auto-generated from loader functions in this package.
// To regenerate, run: go generate ./...
var LoaderRegistry = map[string]func(c *gin.Context) (any, error){
	"/":           LoadIndex,
	"/about":      LoadAbout,
	"/blog/:slug": LoadBlogSlug,
}
```

---

## Part 6: Integration with htgo CLI

### Modify cmd/htgo/commands/dev.go

```go
package commands

import (
	"fmt"
	"os"
	"os/exec"
)

func Dev(project string) error {
	// Run go generate first
	fmt.Println("Generating loaders...")
	cmd := exec.Command("go", "generate", "./...")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to generate loaders: %w", err)
	}

	// Then proceed with dev server...
	return runDevServer(project)
}
```

### Modify cmd/htgo/commands/build.go

```go
package commands

func Build(project string) error {
	// Run go generate first
	fmt.Println("Generating loaders...")
	cmd := exec.Command("go", "generate", "./...")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to generate loaders: %w", err)
	}

	// Then proceed with build...
	return runBuild(project)
}
```

---

## Part 7: Testing the Implementation

### Test Case 1: Simple Pages

```go
// pages/index.go
package pages

func LoadIndex(c *gin.Context) (any, error) {
	return map[string]string{"title": "Home"}, nil
}

// pages/about.go
package pages

func LoadAbout(c *gin.Context) (any, error) {
	return map[string]string{"title": "About"}, nil
}
```

**Expected Output**
```go
var LoaderRegistry = map[string]func(c *gin.Context) (any, error){
	"/":      LoadIndex,
	"/about": LoadAbout,
}
```

### Test Case 2: Nested Routes with Parameters

```go
// pages/blog/[slug].go
package pages

func LoadBlogSlug(c *gin.Context) (any, error) {
	return map[string]string{"slug": c.Param("slug")}, nil
}
```

**Expected Output**
```go
var LoaderRegistry = map[string]func(c *gin.Context) (any, error){
	"/blog/:slug": LoadBlogSlug,
}
```

### Test Case 3: Invalid Functions (Should Be Skipped)

```go
// pages/utils.go
package pages

// Not exported - skipped
func loadHelper() { }

// Wrong signature - skipped
func UtilityFunc(c *gin.Context) string {
	return "wrong return type"
}

// Correct signature - included
func LoadUtility(c *gin.Context) (any, error) {
	return map[string]string{"data": "..."}, nil
}
```

---

## Part 8: Error Handling

### Missing Paired .tsx File

```go
// If pages/about.go exists but pages/about.tsx doesn't
// → pages/about.go is SKIPPED (no error, just ignored)
```

### Invalid Function Signature

```go
// pages/index.go
func LoadIndex(c *gin.Context) string {  // Wrong return type!
	return "hello"
}

// Generation runs, but LoadIndex is NOT included in registry
// → Compiler catches this if you try to use it
```

### Parse Errors

```go
// If a .go file has syntax errors, it's SKIPPED
// Generator continues with other files
// → No hard failure, user can fix file
```

---

## Part 9: Git Integration

### .gitignore

```
# Auto-generated loader registry
pages/loaders_generated.go
```

OR (if you prefer to commit generated files):

```
# Don't ignore generated files - useful for debugging
# pages/loaders_generated.go
```

### Pre-commit Hook (Optional)

```bash
#!/bin/bash
# Run generate before committing
go generate ./...
git add pages/loaders_generated.go
```

---

## Part 10: Migration Path

### Step 1: Add Generator Tool

Create `/cmd/htgo-gen-loaders/main.go` (the code above)

### Step 2: Generate Files for Examples

```bash
go run ./cmd/htgo-gen-loaders -pages examples/sink/app/pages
go run ./cmd/htgo-gen-loaders -pages examples/minimal/pages
```

### Step 3: Update Examples to Use Registry

```go
// examples/sink/app.go
Loaders: pages.LoaderRegistry  // Instead of manual map
```

### Step 4: Add go:generate to Package

```go
// pages/package.go
package pages

//go:generate go run ../../cmd/htgo-gen-loaders -pages . -output loaders_generated.go
```

### Step 5: Update CLI Commands

Modify `cmd/htgo/commands/dev.go` and `build.go` to run `go generate` first

### Step 6: Document in CLAUDE.md

Add section explaining:
- Naming convention (LoadIndex, LoadAbout, etc.)
- How routes are derived from file paths
- How to run generator manually
- How to override if needed

---

## Part 11: Advanced: Manual Overrides

For cases where naming convention doesn't work:

```go
// pages/app.go (after loaders_generated.go is generated)
package pages

// Import gin
import "github.com/gin-gonic/gin"

// Start with auto-generated registry
var CustomRegistry = LoaderRegistry

func init() {
	// Add custom loader with non-standard name
	CustomRegistry["/custom-route"] = CustomLoader
	
	// Override auto-discovered route
	CustomRegistry["/override"] = CustomOverrideLoader
	
	// Remove a loader
	delete(CustomRegistry, "/private")
}

func CustomLoader(c *gin.Context) (any, error) {
	return map[string]string{"custom": "data"}, nil
}

func CustomOverrideLoader(c *gin.Context) (any, error) {
	return map[string]string{"override": "data"}, nil
}
```

Then use `CustomRegistry` instead of `LoaderRegistry`.

---

## Summary

This implementation:

1. **Reuses existing code**: Leverages AST parsing already in router.go
2. **No runtime overhead**: Everything at build time
3. **Simple tool**: Single Go binary that generates one file
4. **Type safe**: Generated code checked by compiler
5. **Reversible**: Easy to disable or modify
6. **Composable**: Can build on top or customize

The generator is straightforward and maintainable - it's not magic, just code analysis + text generation.

